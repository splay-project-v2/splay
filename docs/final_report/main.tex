% EPL master thesis covers template
\documentclass{eplmastersthesis}
\usepackage{float}

% Please fill in the following boxes
% Title of the thesis
\title{Integrated mini-cloud of RaspberryPIs for distributed systems training}

% Subtitle - remove this line if not applicable
\subtitle{The Splay Project}

% Name of the student author(s)
\author{Rémy \textsc{Voet}}
\secondauthor{Samuel \textsc{Monroe}}		% remove if not applicable
%\thirdauthor{Firstname \textsc{Lastname}}			% remove if not applicable

% Official title of the master degree (copy/paste from list below)
% Master [120] in Biomedical Engineering
% Master [120] in Chemical and Materials Engineering
% Master [120] in Civil Engineering
% Master [120] in Computer Science
% Master [120] in Computer Science and Engineering
% Master [120] in Cybersecurity
% Master [120] in Data Sciences Engineering
% Master [120] in Data Science: Information technology
% Master [120] in Electrical Engineering
% Master [120] in Electro-mechanical Engineering
% Master [120] in Mathematical Engineering
% Master [120] in Mechanical Engineering
% Master [120] in Physical Engineering
% Master [60] in Computer Science
% Specialised master in nanotechnologies
% Specialised master in nuclear engineering
\degreetitle{Master [120] in Computer Science}

% Name of the supervisor(s)
\supervisor{Étienne \textsc{Rivière}}
%\secondsupervisor{Firstname \textsc{Lastname}}		% remove if not applicable
%\thirdsupervisor{Firstname \textsc{Lastname}}		% remove if not applicable

% Name of the reader(s)
\readerone{Firstname \textsc{Lastname}}
\readertwo{Firstname \textsc{Lastname}}			% remove if not applicable
\readerthree{Firstname \textsc{Lastname}}			% remove if not applicable
%\readerfour{Firstname \textsc{Lastname}}			% remove if not applicable
%\readerfive{Firstname \textsc{Lastname}}			% remove if not applicable

% Academic year (update if necessary)
\years{2018--2019}

% Document
\begin{document}
  % Front cover page
  \maketitle

  \chapter*{Abstract}

  \chapter*{Acknowledgements}

  \tableofcontents

  \chapter{Introduction}

    \section{Context and Motivations}

      The process of learning distributed systems and algorithms is usually
      undermined by the difficulty of being able for one to test and apply
      what he learns.\\
      Indeed, in order to run a distributed algorithm and observe the result, a
      collection of machines running the algorithm is needed. Besides that,
      one would like to be able to change the conditions in which the algorithm
      is run, for example by provoking faulty nodes, or inducing network
      perturbations among the system, as distributed algorithms are designed to
      adapt to these conditions. These needs make it really cumbersome
      for students to setup a testing environment emulating realistic
      conditions for learning purposes.

    \section{About the Splay Project}

      Discussion about what was available when we started the rework of
      the Splay project.

      \subsection{Legacy Splay Project}

        The SPlay Project at the origin.

      \subsection{A first update}

        About our part-time job on splay and what we have done there.

    \section{Objectives}

      Detailed objectives of the system and our update.

    \section{Features}

      The features available to the users (distributed algorithm editor on the
      web-page, fault injection, topology).

      \subsection{Scenarios}

        Scenarios of usage making use of the different features available.


  \chapter{Software Architecture}

    It is important here to discuss about the software architecture of the
    Splay Project as it has impacts on the way we achieved this work

    \section{Legacy Architecture}

      The old Splay architecture was composed of :

      \begin{itemize}
        \item The \textbf{Controller} : The core part of Splay, waits for jobs
        and dispatch them to the daemons.
        \item \textbf{Daemons} : Workers registering to the controller and waiting
        for jobs to achieve.
        \item A \textbf{MySQL DB} : The communication piece of Splay, allowing
        communication between the user and the system.
        \item A \textbf{CLI Server, CLI Client, SplayWeb} : Pair of CLI tools
        and a web application made in Rails to let user interact with
        Splay through communication with the MySQL Database.
      \end{itemize}

      % Figure of the old architecture, TODO : remake with technologies used
      \begin{figure}[H]
        \centering
        \includegraphics[scale=0.6]{figures/prev_arch.png}
        \caption{\label{prev_arch} Previous Splay Architecture}
      \end{figure}

      Que cela soit à travers l'utilisation du CLI ou de l'application SplayWeb,
      un utilisateur pouvait intéragir avec Splay et y envoyer ses jobs, récupérer
      des informations telles que les logs ou l'état des Splayds.\\

      Le fait que la base de données soit l'élément central de communication entre
      le contrôleur et les applications utilisteurs était un choix de design
      que nous avons choisi de respecter. En effet, le \textbf{Controller} est
      l'élément central du projet Splay, vouloir apporter un changement dans ce choix
      de design et opter pour un remplacement de la façon de communication aurait
      impliqué plus que certainement une réécriture quasi totale du contrôleur.\\

      Cela dit, nous n'étions pas satisfaits par les possibilités d'interactions
      offertes à l'utilisateur. En effet, l'application Ruby on Rails était assez
      vieille, et la paire client/server du command-line-interface possédait une
      codebase difficile à maintenir et trop imposante pour les features qu'elle
      devait proposer.\\

      Nous avons donc choisi d'opérer des changements majeurs sur cette partie
      du projet Splay, afin d'en plus d'opérer les changements et ajouts de features,
      proposer une bonne expérience utilisateur.

    \section{Renewed Architecture}

      Le principal problème du côté de l'architecture des services utilisateurs
      était la duplication de code, ou du moins une duplications des solutions
      apportées pour un seul et même problème. L'application web Rails et le
      serveur CLI avaient en commun la manipulation de la base de données pour
      transmettre et récupérer les informations au \textbf{Controller} pour
      le compte de l'utilisateur.\\

      La première décision à prendre pour pallier à ce problème était de
      fusionner ces deux services en un seul et de l'appeler selon sa responsabilité
      au sein du système, le \textbf{backend} d'un point de vue client.\\
      Ce backend aurait pour ambition de proposer une API sécurisée via
      JsonWebToken et permettant ainsi la construction de services autour de
      ce backend, en l'occurence une application web et un client en ligne
      de commande.\\

      L'application web utiliserait donc une technologie JavaScript récente
      permettant des interactions dynamiques avec l'utilisateur, et le CLI
      une technologie simple et adaptée, les deux consommant l'API fournie
      par le backend. Ce backend resterait quant à lui dans l'écosystème Ruby,
      pour garder une consistance avec le projet tel qu'il était.\\

      On obtiendrait donc l'architecture retravaillée suivante :

      \begin{itemize}
        \item The \textbf{Controller} : The core part of Splay, waits for jobs
        and dispatch them to the daemons.
        \item \textbf{Daemons} : Workers registering to the controller and waiting
        for jobs to achieve.
        \item A \textbf{MySQL DB} : The communication piece of Splay, allowing
        communication between the user and the system.
        \item \textbf{Backend} : The backend of the client side Splay app
        \item A \textbf{Web-app} : The single-page application
        \item A \textbf{CLI} : The command-line interface
      \end{itemize}


      \begin{figure}[H]
        \centering
        \includegraphics[scale=0.105]{figures/new_arch.png}
        \caption{\label{new_arch} New Splay Architecture}
      \end{figure}

  \chapter{Hardware Architecture}

    About the Rasp cluster.

  \chapter{Development Methodology}

    Before talking about the implementation details, we talk about how we actually
    organized ourselves in order to develop the application and ensure quality
    through the Gitflow system and using code reviews along our pull requests
    in order to maintain a global knowledge of the system, even if we had to work
    on different parts of the system.

  \chapter{Implementation}

    Implementation details  (following a story-telling approach?).

    \section{Technology choices}

      Details about the different technologies used.

    \section{Github Repository Cleaning}

      First step was to clean the github repo

    \section{Centralization of Splay's Backend}

      How we moved the old rails app and cli server to a single backend
      to serve any app wanting to connect with Splay.

    \section{A new front-end application}

      As backend was available, development of a VueJS SPA.

    \section{Rework of the CLI to use new Backend}

      All the Command line interface has been redone in Python more clearly and concise.

    \section{Topology creation through Javascript Interface}

    \section{Fault injection}



  \chapter{Testing and Validation}

    Nous allons dans cette section aborder la façon dont nous avons voulu assurer
    le testing et la validation de projet Splay, que ce soit au niveau du système
    ou des fonctionnalités utilisateurs, en ciblant à chaque fois une des
    composantes du projet.\\

    Le fait est que le projet Splay dans l'état où nous l'avons repris disposait
    de très peu de tests, ce qui ne nous a évidemment pas facilité la tâche puisque
    nous avançions dans l'ombre, chaque changement pouvant créer de nouveaux
    dysfonctionnements que nous pourrions remarquer seulemenet longtemps plus tard.\\

    L'écriture des tests s'est déroulée pendant toute la phase de refonte
    architecturale décrite dans la section correspondante, afin de s'assurer
    de la maintenabilité du nouveau code, mais aussi de doter progressivement
    le core de Splay avec des tests pour pouvoir obtenir au final un ensemble
    maintenable.\\

    \section{Backend}

      Pour rappel, le backend tel que nous l'avons conçu a les rôles suivants :
      \begin{itemize}
        \item Responsabilité de la base de données, notamment au niveau de
        la définition de sa structure
        \item Fourni une API JSON permettant à d'autres applications d'interagir
        avec le système
      \end{itemize}

      Le backend étant écrit en Rails, nous avons accès à l'ORM ActiveRecord, qui
      permet une manipulation des données de la database sous forme de modèles.
      Ces modèles sont donc dotés d'attributs, de contraintes à respecter sur
      ces attributs par rapport au schéma de la base de données, mais aussi de
      méthodes. Cette modélisation des données nous permettent donc de faire
      du model testing.\\

      Le fait que le rôle du backend soit de 






  \chapter{Conclusion}

  \nocite{*}
  \bibliographystyle{plain}
  \bibliography{biblio.bib}




  % Back cover page
  \backcoverpage

\end{document}
