% EPL master thesis covers template
\documentclass{eplmastersthesis}
\usepackage{float}

% Please fill in the following boxes
% Title of the thesis
\title{Integrated mini-cloud of RaspberryPIs for distributed systems training}

% Subtitle - remove this line if not applicable
\subtitle{The Splay Project}

% Name of the student author(s)
\author{Rémy \textsc{Voet}}
\secondauthor{Samuel \textsc{Monroe}}		% remove if not applicable
%\thirdauthor{Firstname \textsc{Lastname}}			% remove if not applicable

% Official title of the master degree (copy/paste from list below)
% Master [120] in Biomedical Engineering
% Master [120] in Chemical and Materials Engineering
% Master [120] in Civil Engineering
% Master [120] in Computer Science
% Master [120] in Computer Science and Engineering
% Master [120] in Cybersecurity
% Master [120] in Data Sciences Engineering
% Master [120] in Data Science: Information technology
% Master [120] in Electrical Engineering
% Master [120] in Electro-mechanical Engineering
% Master [120] in Mathematical Engineering
% Master [120] in Mechanical Engineering
% Master [120] in Physical Engineering
% Master [60] in Computer Science
% Specialised master in nanotechnologies
% Specialised master in nuclear engineering
\degreetitle{Master [120] in Computer Science}

% Name of the supervisor(s)
\supervisor{Étienne \textsc{Rivière}}
%\secondsupervisor{Firstname \textsc{Lastname}}		% remove if not applicable
%\thirdsupervisor{Firstname \textsc{Lastname}}		% remove if not applicable

% Name of the reader(s)
\readerone{Firstname \textsc{Lastname}}
\readertwo{Firstname \textsc{Lastname}}			% remove if not applicable
\readerthree{Firstname \textsc{Lastname}}			% remove if not applicable
%\readerfour{Firstname \textsc{Lastname}}			% remove if not applicable
%\readerfive{Firstname \textsc{Lastname}}			% remove if not applicable

% Academic year (update if necessary)
\years{2018--2019}

% Document
\begin{document}
  % Front cover page
  \maketitle

  \chapter*{Abstract}

  \chapter*{Acknowledgements}

  \tableofcontents

  \chapter{Introduction}

    \section{Context and Motivations}

      The process of learning distributed systems and algorithms is usually
      undermined by the difficulty of being able for one to test and apply
      what he learns.\\
      Indeed, in order to run a distributed algorithm and observe the result, a
      collection of machines running the algorithm is needed. Besides that,
      one would like to be able to change the conditions in which the algorithm
      is run, for example by provoking faulty nodes, or inducing network
      perturbations among the system, as distributed algorithms are designed to
      adapt to these conditions. These needs make it really cumbersome
      for students to setup a testing environment emulating realistic
      conditions for learning purposes.

    \section{About the Splay Project}

      Discussion about what was available when we started the rework of
      the Splay project.

      \subsection{Legacy Splay Project}

        The SPlay Project at the origin.

      \subsection{A first update}

        About our part-time job on splay and what we have done there.

  \chapter{Splay Version 2}

    All about what we wanted to do exactly.

    \section{Objectives}

      Detailed objectives of the system and our update.

    \section{Features}

      The features available to the users (distributed algorithm editor on the
      web-page, fault injection, topology).

      \subsection{Scenarios}

        Scenarios of usage making use of the different features available.

  \chapter{Architecture}

    \section{Software Architecture}

      It is important here to discuss about the software architecture of the
      Splay Project as it has impacts on the way we achieved this work

      \subsection{Legacy Architecture}

        The old Splay architecture was composed of :

        \begin{itemize}
          \item The \textbf{Controller} : The core part of Splay, waits for jobs
          and dispatch them to the daemons.
          \item \textbf{Daemons} : Workers registering to the controller and waiting
          for jobs to achieve.
          \item A \textbf{MySQL DB} : The communication piece of Splay, allowing
          communication between the user and the system.
          \item A \textbf{CLI Server, CLI Client, SplayWeb} : Pair of CLI tools
          and a web application made in Rails to let user interact with
          Splay through communication with the MySQL Database.
        \end{itemize}

        % Figure of the old architecture, TODO : remake with technologies used
        \begin{figure}[H]
          \centering
          \includegraphics[scale=0.6]{figures/prev_arch.png}
          \caption{\label{prev_arch} Previous Splay Architecture}
        \end{figure}

        Que cela soit à travers l'utilisation du CLI ou de l'application SplayWeb,
        un utilisateur pouvait intéragir avec Splay et y envoyer ses jobs, récupérer
        des informations telles que les logs ou l'état des Splayds.\\

        Le fait que la base de données soit l'élément central de communication entre
        le contrôleur et les applications utilisteurs était un choix de design
        que nous avons choisi de respecter. En effet, le \textbf{Controller} est
        l'élément central du projet Splay, vouloir apporter un changement dans ce choix
        de design et opter pour un remplacement de la façon de communication aurait
        impliqué plus que certainement une réécriture quasi totale du contrôleur.\\

        Cela dit, nous n'étions pas satisfaits par les possibilités d'interactions
        offertes à l'utilisateur. En effet, l'application Ruby on Rails était assez
        vieille, et la paire client/server du command-line-interface possédait une
        codebase difficile à maintenir et trop imposante pour les features qu'elle
        devait proposer.\\

        Nous avons donc choisi d'opérer des changements majeurs sur cette partie
        du projet Splay, afin d'en plus d'opérer les changements et ajouts de features,
        proposer une bonne expérience utilisateur.

      \subsection{Renewed Architecture}

        Le principal problème du côté de l'architecture des services utilisateurs
        était la duplication de code, ou du moins une duplications des solutions
        apportées pour un seul et même problème. L'application web Rails et le
        serveur CLI avaient en commun la manipulation de la base de données pour
        transmettre et récupérer les informations au \textbf{Controller} pour
        le compte de l'utilisateur.\\

        La première décision à prendre pour pallier à ce problème était de
        fusionner ces deux services en un seul et de l'appeler selon sa responsabilité
        au sein du système, le \textbf{backend} d'un point de vue client.\\
        Ce backend aurait pour ambition de proposer une API sécurisée via
        JsonWebToken et permettant ainsi la construction de services autour de
        ce backend, en l'occurence une application web et un client en ligne
        de commande.\\

        L'application web utiliserait donc une technologie JavaScript récente
        permettant des interactions dynamiques avec l'utilisateur, et le CLI
        une technologie simple et adaptée, les deux consommant l'API fournie
        par le backend. Ce backend resterait quant à lui dans l'écosystème Ruby,
        pour garder une consistance avec le projet tel qu'il était.\\

        On obtiendrait donc l'architecture retravaillée suivante :

        \begin{itemize}
          \item The \textbf{Controller} : The core part of Splay, waits for jobs
          and dispatch them to the daemons.
          \item \textbf{Daemons} : Workers registering to the controller and waiting
          for jobs to achieve.
          \item A \textbf{MySQL DB} : The communication piece of Splay, allowing
          communication between the user and the system.
          \item \textbf{Backend} : The backend of the client side Splay app
          \item A \textbf{Web-app} : The single-page application
          \item A \textbf{CLI} : The command-line interface
        \end{itemize}

        \begin{figure}[H]
          \centering
          \includegraphics[scale=0.105]{figures/new_arch.png}
          \caption{\label{new_arch} New Splay Architecture}
        \end{figure}

    \section{Hardware Architecture}

      About the Rasp cluster.

  \chapter{Development Methodology}

    Avant de parler des détails d'implémentation, il est utile de décrire la
    façon dont nous nous sommes organisés afin de développer l'application, le
    fait d'être deux à faire ce travail nécessitait forcément une façon de
    s'organiser un peu plus sérieuse qu'un développement seul.\\

    Grâce à des cours suivis pendant notre cursus au sujet de méthodologies
    AGILES, et ayant tous deux eu l'occasion d'acquérir de l'expérience de manière
    professionnelle au travers de stages et de part-times jobs, nous avons
    voulu mettre à l'oeuvre ces connaissances et bonnes pratiques acquises dans
    le domaine de la gestion de projet.

      \section{Kanban}

        Le premier outil que nous avons mis en place, et ce dès notre période
        d'update de Splay dont nous avons parlé plus tôt, a été un Kanban en
        utilisant le site en ligne Trello. Le kanban nous a permis de : \\

        \begin{itemize}
          \item Avoir une vue claire et précise sur les tâches à accomplir restantes
          dans le backlog, ainsi que de l'état de développement des autres tâches.
          \item Nous pousser à traduire les features à réaliser en cartes
          suffisamment détaillées et explicites, pouvant aboutir à des clarifications
          ou refontes de certaines features avant le début de leur développement.
          \item Avoir un moyen de tracking de l'avancement du projet et fournir aux
           personnes impliquées dans le projet Splay un moyen simple et efficace
           de se tenir informer sur l'état de Splay.
          \item Se concentrer sur des tâches spécifiques et travailler de manière
          itérative et efficace.
        \end{itemize}

      \section{Quality Assurance}

        Ceci sera explicité plus en détail dans un chapitre suivant, mais nous
        avons voulu nous assurer de maintenir un certain degré de qualité dans
        notre travail sur Splay et plus spécifiquement au niveau du code, afin
        aussi d'assurer la maintenabilité du projet. Nous nous sommes donc
        fixés ce but à travers la mise en place des éléments suivants : \\

        \begin{itemize}
          \item \textbf{Testing suites} : Ensembles de tests unitaires et
          d'intégration, intra-service et inter-services.
          \item \textbf{Linter} : Analyse statique du code afin de satisfaire à
          des exigeances de style de code et de bonnes pratiques.
          \item \textbf{Coverage Analyzers} : Analyse du pourcentage de couverture
          du code par les suites de tests.
        \end{itemize}

      \section{Github and Gitflow}

        Le projet et les divers services qui le composent sont versionnés
        en utilisant le système de versionning \textit{Git} et hostés
        sur le service en ligne \textit{Github}.
        Nous avons donc organisés notre travail sur le modèle du Gitflow.
        Chaque feature ou tâche que nous avions créée sur le kanban était
        destinée à recevoir sa propre branche, partant de la branche principale.
        Une fois la feature terminée et testée, une pull request était créée
        demandant la fusion de la branche de feature sur la branche principale.
        Le bénéfice premier étant évidemment de garder la branche principale
        dans un état fonctionnel avec des features implémentées terminées et
        saines.\\

        Le deuxième atout de cette méthode de travail au sein de notre groupe
        était de pouvoir, encore dans un but d'assurer la qualité, aisément
        organiser du reviewing de code entre nous. Chaque fois qu'un de nous
        finissait une tâche et effectuait une pull request, l'autre était
        assigné en tant que reviewer et chargé d'accepter la pull request
        et d'effectuer le merge, ou détecter des erreurs à l'issue de cette
        review et de demander les changements adéquats au premier.\\
        Outre le bénéfice premier de la review dans la réduction du nombre
        de bugs ou d'erreurs, cela permettait aussi à chacun d'entre nous
        de rester au courant de tous les changements au sein des différents
        services, puisque nous ne pouvions pas décemment travailler ensemble
        sur chaque service individuellement étant donné leur nombre et les
        features inter-dépendantes à développer.


  \chapter{Implementation}

    Implementation details  (following a story-telling approach?).

    \section{Technology choices}

      Details about the different technologies used.

    \section{Github Repository Cleaning}

      First step was to clean the github repo

    \section{Centralization of Splay's Backend}

      How we moved the old rails app and cli server to a single backend
      to serve any app wanting to connect with Splay.

    \section{A new front-end application}

      As backend was available, development of a VueJS SPA.

    \section{Rework of the CLI to use new Backend}

      All the Command line interface has been redone in Python more clearly and concise.

    \section{Topology creation through Javascript Interface}

    \section{Fault injection}

  \chapter{Testing and Validation}

    Nous allons dans cette section aborder la façon dont nous avons voulu assurer
    le testing et la validation de projet Splay, que ce soit au niveau du système
    ou des fonctionnalités utilisateurs, en ciblant à chaque fois une des
    composantes du projet.\\

    Le fait est que le projet Splay dans l'état où nous l'avons repris disposait
    de très peu de tests, ce qui ne nous a évidemment pas facilité la tâche puisque
    nous avançions dans l'ombre, chaque changement pouvant créer de nouveaux
    dysfonctionnements que nous pourrions remarquer seulemenet longtemps plus tard.\\

    L'écriture des tests s'est déroulée pendant toute la phase de refonte
    architecturale décrite dans la section correspondante, afin de s'assurer
    de la maintenabilité du nouveau code, mais aussi de doter progressivement
    le core de Splay avec des tests pour pouvoir obtenir au final un ensemble
    maintenable.\\

    \section{Backend}

      Pour rappel, le backend tel que nous l'avons conçu a les rôles suivants :
      \begin{itemize}
        \item Responsabilité de la base de données, notamment au niveau de
        la définition de sa structure.
        \item Fourni une API JSON permettant à d'autres applications d'interagir
        avec le système.
      \end{itemize}

      Le backend étant écrit en Rails, nous avons accès à l'ORM ActiveRecord, qui
      permet une manipulation des données de la database sous forme de modèles.
      Ces modèles sont donc dotés d'attributs, de contraintes à respecter sur
      ces attributs par rapport au schéma de la base de données, mais aussi de
      méthodes. Cette modélisation des données nous permettent donc de faire
      du model testing.\\

      Le rôle du backend étant uniquement de fournir une JSON API
      aux différents services clients à travers une authentification utilisant
      JSON Web Token, une suite de request testing devait venir valider
      notre ensemble d'endpoints ainsi que les méchanismes d'authentification.
      Les données étant renvoyées aux applications sous forme de réponses
      JSON, une sérialization des modèles devait aussi être appliquée et donc
      également sujette à une série de tests.

      \subsection{RSpec}

        RSpec est une librairie destinée au Behaviour Driven Development
        pour Ruby. Le BDD était une pratique que nous voulions suivre pour
        la reprise du développement de Splay, nous permettant d'adopter
        un cycle red-green-refactor mais aussi de pouvoir nous concentrer sur
        la rédaction de scénarios en langage naturels et ensuite de les
        traduire en scénarios de tests.

        \subsubsection{Model Testing}

          Comme explicité plus haut, la couche ORM de Rails nous offre un
          reflet des contraintes présentes dans la base de données en représentant
          ses tables sous forme de modèles dotés d'attributs, que nous pouvons en
          plus doter d'attributs supplémentaires, de méthodes et d'une surcouche
          de validations supplémentaires (par exemple sur des combinaisons d'attributs,
          ou des contraintes plus complexes inter-tables).\\

          Cette abstraction supplémentaire nécessite en effet d'être couverte par
          un ensemble suffisant de validation, ce que nous avons fait à travers
          du \textbf{Model Testing}, en mettant à l'épreuve la surcouche appliquée
          aux modèles mais aussi les contraintes de bases explicitées dans le
          schéma de la base de données.\\

          Cet ensemble de tests offrent donc une double validation sur les contraintes
          de champs, mais aussi une validation sur la logique business ajoutée
          dans l'application.

        \subsubsection{Request Testing}

          Les tests de requêtes au sein du Backend sont les tests les plus
          importants que nous avons réalisés, en termes de couverture de la
          codebase mais aussi en termes d'exploration des features implémentées
          au sein de ce service de Splay.\\

          Les "requests specs" au sein de RSpec sont faites pour simuler un
          comportement d'application utilisateur faisant appel à tout le stack
          de Rails (un framework web MVC).
          Chaque requête passe donc au travers des éléments suivants :\\

          % INSERT SCHEMA HERE
          \begin{figure}[H]
            \centering
            \includegraphics[scale=0.6]{figures/request_test.png}
            \caption{\label{new_arch} Request Lifetime in Backend Service}
          \end{figure}

          Chaque route de l'application est testée, en explorant différent
          scénarios possibles (token d'authentification invalide, action
          non autorisée pour l'utilisateur). On a donc une série de tests
          qui mettent en oeuvre l'intégralité de l'application, avec simplement
          un envoi de requêtes et une comparaison sur les réponses attendues
          de la part de l'application.

      \subsection{Code Coverage - Simple Cov}

        Nous avons choisi d'utiliser Simple Cov en combinaison du testing appliqué
        au Backend. Cet outil permet de mesure le code coverage d'une application
        Ruby et de fournir des informations utiles grâce à une analyse des
        exécutions des tests.\\

        Notre ambition sur la partie utilisateur de Splay ayant été une refonte
        des services en services plus simples et maintenables, il était dès lors
        simple et évident d'atteindre une couverture totale avec une suite de tests,
        et avons décidé d'utiliser cet outil.

      \subsection{Code Quality - Rubocop}

        Dernière partie de l'ensemble d'outils destinés à assurer la qualité du
        service, nous avons utilisé Rubocop, un outil d'analyse statique du code
        (linter) permettant de détecter les enfreintes à une série de codes
        de conduites en termes de style et pratiques (méthodes trop longues,
        trop d'instanciations de variables, trop d'embranchements dans le code, ...).

      \subsection{Integration Continue}

        Encore dans un soucis de qualité, le service a été placé sur la plateforme
        d'intégration continue Travis CI, le but étant de se servir des hooks
        fournis par Travis sur l'exécution des tests.\\

        Splay étant un projet open source, et que nous espérons voir évoluer, son
        développment collaboratif se fera inévitablement à travers l'organisation
        Github dans laquelle les repositories se trouvent.\\
        Les hooks Travis permettent, dans le cadre d'une pull request, d'obtenir
        une review de l'exécution de tests sur la branche qui demande à être
        mergée, et de s'assurer que le build est sain.

  \chapter{Conclusion}

  \chapter{Improvements}


  \nocite{*}
  \bibliographystyle{plain}
  \bibliography{biblio.bib}




  % Back cover page
  \backcoverpage

\end{document}
